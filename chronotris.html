<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHRONOTRIS - Multi-Timeline Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            font-size: 2.5em;
            margin: 20px 0;
            text-align: center;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            font-style: italic;
            color: #aaa;
        }

        #gameContainer {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .timeline {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .timeline h2 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .timeline.past h2 { color: #ff6b6b; }
        .timeline.present h2 { color: #4ecdc4; }
        .timeline.future h2 { color: #45b7d1; }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            display: block;
            background: rgba(0, 0, 0, 0.3);
        }

        #controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-width: 800px;
            width: 100%;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.9em;
            color: #aaa;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #timeSpliceBtn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .message {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
        }

        .message.cascade {
            background: rgba(255, 107, 107, 0.2);
            border: 2px solid #ff6b6b;
        }

        .message.splice {
            background: rgba(245, 87, 108, 0.2);
            border: 2px solid #f5576c;
        }

        .message.paradox {
            background: rgba(255, 193, 7, 0.2);
            border: 2px solid #ffc107;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .instructions {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            max-width: 800px;
        }

        .instructions h3 {
            margin-bottom: 10px;
            color: #4ecdc4;
        }

        .instructions ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .instructions kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 3px 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
        }

        #gameOver {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            border: 3px solid #4ecdc4;
            text-align: center;
            z-index: 1000;
            min-width: 400px;
        }

        #gameOver h2 {
            color: #4ecdc4;
            margin-bottom: 20px;
            font-size: 2em;
        }

        #gameOver .final-score {
            font-size: 3em;
            color: #ff6b6b;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>‚è∞ CHRONOTRIS ‚è∞</h1>
    <p class="subtitle">Navigate Three Timelines Simultaneously</p>

    <div id="gameContainer">
        <div class="timeline past">
            <h2>üìú PAST</h2>
            <canvas id="pastCanvas" width="200" height="400"></canvas>
        </div>
        <div class="timeline present">
            <h2>‚ö° PRESENT</h2>
            <canvas id="presentCanvas" width="200" height="400"></canvas>
        </div>
        <div class="timeline future">
            <h2>üîÆ FUTURE</h2>
            <canvas id="futureCanvas" width="200" height="400"></canvas>
        </div>
    </div>

    <div id="controls">
        <div class="stats">
            <div class="stat">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Lines</div>
                <div class="stat-value" id="lines">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Active Timeline</div>
                <div class="stat-value" id="activeTimeline">PAST</div>
            </div>
            <div class="stat">
                <div class="stat-label">Time Splices</div>
                <div class="stat-value" id="splicesLeft">3</div>
            </div>
        </div>

        <div class="message" id="message">Use 1/2/3 to switch timelines. Press S for Time Splice!</div>

        <div class="buttons">
            <button id="startBtn">Start Game</button>
            <button id="pauseBtn" disabled>Pause</button>
            <button id="timeSpliceBtn" disabled>‚ö° TIME SPLICE (3 left)</button>
        </div>
    </div>

    <div class="instructions">
        <h3>How to Play</h3>
        <ul>
            <li><kbd>‚Üê</kbd> <kbd>‚Üí</kbd> Move piece in active timeline</li>
            <li><kbd>‚Üë</kbd> Rotate piece</li>
            <li><kbd>‚Üì</kbd> Soft drop</li>
            <li><kbd>Space</kbd> Hard drop</li>
            <li><kbd>S</kbd> Activate Time Splice (3 uses per game)</li>
            <li><kbd>1</kbd> <kbd>2</kbd> <kbd>3</kbd> Switch between Past, Present, Future timelines</li>
            <li><strong>Temporal Cascade:</strong> Clearing a line in PAST causes blocks in PRESENT to shift down!</li>
            <li><strong>Future Echo:</strong> See ghostly previews of upcoming pieces in FUTURE timeline</li>
            <li><strong>Time Splice:</strong> Press S to merge all three timelines for 10 seconds</li>
            <li><strong>Paradox Penalty:</strong> Random garbage appears if you create impossible temporal states</li>
        </ul>
    </div>

    <div id="gameOver">
        <h2>Timeline Collapsed!</h2>
        <div class="final-score" id="finalScore">0</div>
        <p id="finalStats"></p>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <script>
        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 20;
        const COLORS = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#feca57', '#ee5a6f', '#48dbfb', '#1dd1a1'];

        // Tetromino shapes
        const SHAPES = {
            'I': [[1,1,1,1]],
            'O': [[1,1],[1,1]],
            'T': [[0,1,0],[1,1,1]],
            'S': [[0,1,1],[1,1,0]],
            'Z': [[1,1,0],[0,1,1]],
            'J': [[1,0,0],[1,1,1]],
            'L': [[0,0,1],[1,1,1]]
        };

        // Game state
        let gameState = {
            score: 0,
            lines: 0,
            gameStarted: false,
            gamePaused: false,
            splicesLeft: 3,
            splicing: false,
            spliceTimer: 0,
            activeTimeline: 0, // 0=Past, 1=Present, 2=Future
            paradoxCount: 0
        };

        // Timeline boards
        let timelines = [
            { name: 'PAST', board: createBoard(), piece: null, color: '#ff6b6b' },
            { name: 'PRESENT', board: createBoard(), piece: null, color: '#4ecdc4' },
            { name: 'FUTURE', board: createBoard(), piece: null, color: '#45b7d1' }
        ];

        // Canvas contexts
        const contexts = [
            document.getElementById('pastCanvas').getContext('2d'),
            document.getElementById('presentCanvas').getContext('2d'),
            document.getElementById('futureCanvas').getContext('2d')
        ];

        // UI elements
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const timeSpliceBtn = document.getElementById('timeSpliceBtn');
        const message = document.getElementById('message');

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
        }

        function createPiece() {
            const shapes = Object.keys(SHAPES);
            const shape = shapes[Math.floor(Math.random() * shapes.length)];
            return {
                shape: SHAPES[shape],
                x: Math.floor(COLS / 2) - 1,
                y: 0,
                color: COLORS[Math.floor(Math.random() * COLORS.length)]
            };
        }

        function draw() {
            timelines.forEach((timeline, idx) => {
                const ctx = contexts[idx];
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);

                // Draw board
                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (timeline.board[y][x]) {
                            ctx.fillStyle = timeline.board[y][x];
                            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
                        }
                    }
                }

                // Draw current piece
                if (timeline.piece) {
                    const alpha = (idx === gameState.activeTimeline || gameState.splicing) ? 1.0 : 0.3;
                    ctx.globalAlpha = alpha;

                    timeline.piece.shape.forEach((row, y) => {
                        row.forEach((value, x) => {
                            if (value) {
                                ctx.fillStyle = timeline.piece.color;
                                ctx.fillRect(
                                    (timeline.piece.x + x) * BLOCK_SIZE,
                                    (timeline.piece.y + y) * BLOCK_SIZE,
                                    BLOCK_SIZE - 1,
                                    BLOCK_SIZE - 1
                                );
                            }
                        });
                    });
                    ctx.globalAlpha = 1.0;
                }

                // Draw future echo (ghost pieces in future timeline)
                if (idx === 2 && timeline.piece && !gameState.splicing) {
                    ctx.globalAlpha = 0.2;
                    for (let i = 1; i <= 3; i++) {
                        ctx.fillStyle = '#fff';
                        timeline.piece.shape.forEach((row, y) => {
                            row.forEach((value, x) => {
                                if (value) {
                                    ctx.fillRect(
                                        (timeline.piece.x + x + i * 3) % COLS * BLOCK_SIZE,
                                        ((timeline.piece.y + y + i * 2) % ROWS) * BLOCK_SIZE,
                                        BLOCK_SIZE - 1,
                                        BLOCK_SIZE - 1
                                    );
                                }
                            });
                        });
                    }
                    ctx.globalAlpha = 1.0;
                }

                // Draw active timeline indicator
                if (idx === gameState.activeTimeline && !gameState.splicing) {
                    ctx.strokeStyle = timeline.color;
                    ctx.lineWidth = 3;
                    ctx.strokeRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                }

                // Draw splice effect
                if (gameState.splicing) {
                    ctx.strokeStyle = '#f5576c';
                    ctx.lineWidth = 5;
                    ctx.strokeRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
                }
            });
        }

        function collides(piece, board, offsetX = 0, offsetY = 0) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
                        if (newY >= 0 && board[newY][newX]) return true;
                    }
                }
            }
            return false;
        }

        function merge(piece, board) {
            piece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        const boardY = piece.y + y;
                        const boardX = piece.x + x;
                        if (boardY >= 0 && boardY < ROWS && boardX >= 0 && boardX < COLS) {
                            board[boardY][boardX] = piece.color;
                        }
                    }
                });
            });
        }

        function clearLines(timelineIdx) {
            let linesCleared = 0;
            const timeline = timelines[timelineIdx];

            for (let y = ROWS - 1; y >= 0; y--) {
                if (timeline.board[y].every(cell => cell !== null)) {
                    timeline.board.splice(y, 1);
                    timeline.board.unshift(Array(COLS).fill(null));
                    linesCleared++;
                    y++;
                }
            }

            if (linesCleared > 0) {
                gameState.lines += linesCleared;
                gameState.score += linesCleared * 100 * (timelineIdx + 1);

                // Temporal Cascade: clearing in PAST affects PRESENT
                if (timelineIdx === 0) {
                    showMessage('üåä TEMPORAL CASCADE! Present timeline shifted!', 'cascade');
                    shiftTimeline(1, linesCleared);
                }

                updateStats();
            }
        }

        function shiftTimeline(timelineIdx, amount) {
            const timeline = timelines[timelineIdx];
            for (let i = 0; i < amount; i++) {
                // Add garbage line at top (with a gap for fairness)
                const garbageRow = Array(COLS).fill(null);
                const gapPos = Math.floor(Math.random() * COLS);
                for (let x = 0; x < COLS; x++) {
                    if (x !== gapPos) {
                        garbageRow[x] = '#555'; // Darker color for temporal garbage
                    }
                }
                // Remove bottom row and add garbage at top
                timeline.board.pop();
                timeline.board.unshift(garbageRow);
            }

            // Check for paradox (blocks appearing without cause)
            checkParadox(timelineIdx);
        }

        function checkParadox(timelineIdx) {
            // Random chance of paradox when temporal mechanics are violated
            if (Math.random() < 0.3) {
                gameState.paradoxCount++;
                showMessage('‚ö†Ô∏è PARADOX DETECTED! Garbage blocks materialized!', 'paradox');
                addGarbageBlocks(timelineIdx, 2);
            }
        }

        function addGarbageBlocks(timelineIdx, count) {
            const timeline = timelines[timelineIdx];
            for (let i = 0; i < count; i++) {
                const row = Array(COLS).fill(0);
                const gapPos = Math.floor(Math.random() * COLS);
                for (let x = 0; x < COLS; x++) {
                    if (x !== gapPos) {
                        row[x] = '#666';
                    }
                }
                timeline.board.push(row);
                timeline.board.shift();
            }
        }

        function rotate(piece) {
            const rotated = piece.shape[0].map((_, i) =>
                piece.shape.map(row => row[i]).reverse()
            );
            return { ...piece, shape: rotated };
        }

        function moveDown(timelineIdx) {
            const timeline = timelines[timelineIdx];
            if (!timeline.piece) return false;

            if (!collides(timeline.piece, timeline.board, 0, 1)) {
                timeline.piece.y++;
                return true;
            } else {
                merge(timeline.piece, timeline.board);
                clearLines(timelineIdx);
                timeline.piece = createPiece();

                if (collides(timeline.piece, timeline.board)) {
                    gameOver();
                    return false;
                }
            }
            return false;
        }

        function hardDrop(timelineIdx) {
            const timeline = timelines[timelineIdx];
            if (!timeline.piece) return;

            let dropDistance = 0;
            while (!collides(timeline.piece, timeline.board, 0, 1)) {
                timeline.piece.y++;
                dropDistance++;
            }

            gameState.score += dropDistance * 2;
            merge(timeline.piece, timeline.board);
            clearLines(timelineIdx);
            timeline.piece = createPiece();

            if (collides(timeline.piece, timeline.board)) {
                gameOver();
            }

            updateStats();
        }

        function activateTimeSplice() {
            if (gameState.splicesLeft <= 0 || gameState.splicing) return;

            gameState.splicing = true;
            gameState.splicesLeft--;
            gameState.spliceTimer = 10;

            showMessage('‚ö° TIME SPLICE ACTIVE! All timelines merged for 10 seconds!', 'splice');
            updateStats();

            timeSpliceBtn.disabled = true;
            timeSpliceBtn.textContent = `‚ö° SPLICING... (${gameState.spliceTimer}s)`;
        }

        function updateTimeSplice() {
            if (gameState.splicing) {
                gameState.spliceTimer -= 0.1;
                timeSpliceBtn.textContent = `‚ö° SPLICING... (${Math.ceil(gameState.spliceTimer)}s)`;

                if (gameState.spliceTimer <= 0) {
                    gameState.splicing = false;
                    showMessage('Time splice ended. Timelines separated.', '');

                    if (gameState.splicesLeft > 0) {
                        timeSpliceBtn.disabled = false;
                        timeSpliceBtn.textContent = `‚ö° TIME SPLICE (${gameState.splicesLeft} left)`;
                    } else {
                        timeSpliceBtn.textContent = '‚ö° TIME SPLICE (DEPLETED)';
                    }
                }
            }
        }

        function showMessage(text, type) {
            message.textContent = text;
            message.className = 'message ' + type;
            setTimeout(() => {
                if (message.textContent === text) {
                    message.textContent = 'Use 1/2/3 to switch timelines. SPACE for Time Splice!';
                    message.className = 'message';
                }
            }, 3000);
        }

        function updateStats() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lines').textContent = gameState.lines;
            document.getElementById('activeTimeline').textContent = timelines[gameState.activeTimeline].name;
            document.getElementById('splicesLeft').textContent = gameState.splicesLeft;
        }

        function gameOver() {
            gameState.gameStarted = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = gameState.score;
            document.getElementById('finalStats').innerHTML = `
                Lines Cleared: ${gameState.lines}<br>
                Time Splices Used: ${3 - gameState.splicesLeft}<br>
                Paradoxes Created: ${gameState.paradoxCount}
            `;
        }

        let dropCounter = 0;
        let dropInterval = 1000;
        let lastTime = 0;

        function gameLoop(time = 0) {
            if (!gameState.gameStarted || gameState.gamePaused) {
                requestAnimationFrame(gameLoop);
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval) {
                if (gameState.splicing) {
                    // During splice, all timelines move
                    timelines.forEach((_, idx) => moveDown(idx));
                } else {
                    // Only active timeline moves
                    moveDown(gameState.activeTimeline);
                }
                dropCounter = 0;
            }

            updateTimeSplice();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Controls
        document.addEventListener('keydown', (e) => {
            if (!gameState.gameStarted || gameState.gamePaused) return;

            const timelines_to_control = gameState.splicing ? [0, 1, 2] : [gameState.activeTimeline];

            switch(e.key) {
                case 'ArrowLeft':
                    timelines_to_control.forEach(idx => {
                        const timeline = timelines[idx];
                        if (timeline.piece && !collides(timeline.piece, timeline.board, -1, 0)) {
                            timeline.piece.x--;
                        }
                    });
                    break;
                case 'ArrowRight':
                    timelines_to_control.forEach(idx => {
                        const timeline = timelines[idx];
                        if (timeline.piece && !collides(timeline.piece, timeline.board, 1, 0)) {
                            timeline.piece.x++;
                        }
                    });
                    break;
                case 'ArrowDown':
                    timelines_to_control.forEach(idx => {
                        moveDown(idx);
                    });
                    break;
                case 'ArrowUp':
                    timelines_to_control.forEach(idx => {
                        const timeline = timelines[idx];
                        if (timeline.piece) {
                            const rotated = rotate(timeline.piece);
                            if (!collides(rotated, timeline.board)) {
                                timeline.piece = rotated;
                            }
                        }
                    });
                    break;
                case ' ':
                    e.preventDefault();
                    timelines_to_control.forEach(idx => hardDrop(idx));
                    break;
                case 's':
                case 'S':
                    e.preventDefault();
                    if (!gameState.splicing && gameState.splicesLeft > 0) {
                        activateTimeSplice();
                    }
                    break;
                case '1':
                    if (!gameState.splicing) gameState.activeTimeline = 0;
                    updateStats();
                    break;
                case '2':
                    if (!gameState.splicing) gameState.activeTimeline = 1;
                    updateStats();
                    break;
                case '3':
                    if (!gameState.splicing) gameState.activeTimeline = 2;
                    updateStats();
                    break;
            }
            draw();
        });

        startBtn.addEventListener('click', () => {
            gameState.gameStarted = true;
            gameState.score = 0;
            gameState.lines = 0;
            gameState.splicesLeft = 3;
            gameState.splicing = false;
            gameState.activeTimeline = 0;
            gameState.paradoxCount = 0;

            timelines = [
                { name: 'PAST', board: createBoard(), piece: createPiece(), color: '#ff6b6b' },
                { name: 'PRESENT', board: createBoard(), piece: createPiece(), color: '#4ecdc4' },
                { name: 'FUTURE', board: createBoard(), piece: createPiece(), color: '#45b7d1' }
            ];

            startBtn.disabled = true;
            pauseBtn.disabled = false;
            timeSpliceBtn.disabled = false;
            timeSpliceBtn.textContent = '‚ö° TIME SPLICE (3 left)';

            updateStats();
            document.getElementById('gameOver').style.display = 'none';
            gameLoop();
        });

        pauseBtn.addEventListener('click', () => {
            gameState.gamePaused = !gameState.gamePaused;
            pauseBtn.textContent = gameState.gamePaused ? 'Resume' : 'Pause';
        });

        timeSpliceBtn.addEventListener('click', activateTimeSplice);

        // Initial draw
        draw();
    </script>
</body>
</html>
